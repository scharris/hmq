{-# OPTIONS_GHC -fglasgow-exts #-}

-- This file is public domain.

module HMQ.Example.MovieRentals where

import Numeric
import Control.Exception
import Control.Monad
import System.Time
import Data.List
import qualified Database.HDBC as HDBC
import Database.HDBC.PostgreSQL(connectPostgreSQL)

-- Import the entity modules, which were generated by genFiles defined below
import qualified HMQ.Example.GeneratedEntities.Accounts as Accounts
import qualified HMQ.Example.GeneratedEntities.Categories as Categories
import qualified HMQ.Example.GeneratedEntities.Customers as Customers
import qualified HMQ.Example.GeneratedEntities.Discs as Discs
import qualified HMQ.Example.GeneratedEntities.Employees as Employees
import qualified HMQ.Example.GeneratedEntities.Movies as Movies
import qualified HMQ.Example.GeneratedEntities.Rentals as Rentals
import qualified HMQ.Example.GeneratedEntities.Stores as Stores

import HMQ.Example.GeneratedForeignKeyLinks

import HMQ.MappedQuery(MappedQuery(..))
import qualified HMQ.MappedQuery as MQ
import qualified HMQ.Metadata.PostgreSQL -- TODO: export this from TableMetadata instead
import qualified HMQ.Metadata.TableMetadata as TMD
import qualified HMQ.ReverseEngineering as RE



testConnStr = "dbname='testdb' user='sharris' password='anna'"



printMds = 
    do
      conn <- connectPostgreSQL testConnStr

      TMD.printTableMetadatas conn


genFiles :: IO ()
genFiles =
    do
      conn <- connectPostgreSQL testConnStr

      tableMds <- TMD.getTableMetadatas conn (Just "public")

      RE.generateEntityModuleSourceFiles options "../.." tableMds -- the root of the package heirarchy (HMQ.Example.*) is two directories up

      RE.generateForeignKeyLinksModuleSourceFile options "../.." tableMds

    where
      options = RE.defaultOptions {
                  RE.outputModulesQualifiedNamesPrefix = "HMQ.Example.",
                  RE.entityNamingFunction = customEntityNamingFunction
                }
      customEntityNamingFunction tableId = 
          if "movies" == TMD.tableName tableId then "Movie" 
          else RE.defaultEntityNamingFunction tableId


runWithoutMapping :: MappedQuery a b t -> IO [[HDBC.SqlValue]]
runWithoutMapping mq =
    catchDyn doQry printSqlError
    where
      doQry = do
        conn <- connectPostgreSQL testConnStr
        HDBC.quickQuery conn (MQ.toSqlString mq) []

      printSqlError :: HDBC.SqlError -> IO [[HDBC.SqlValue]]
      printSqlError se = do { print se; return [] }

runMQ :: MappedQuery a b t -> IO [t]
runMQ mq = 
    do 
      conn <- connectPostgreSQL testConnStr
      MQ.run conn mq

mq1 = InnerJoin customers
                customers'account_id 
                accounts

sql1 = MQ.toSqlString mq1

mq2 = LeftOuterJoin rentals
                    rentals'customer_id
                    mq1

rawRes1 = runWithoutMapping mq1 
res1 = runMQ mq1



runTest =
    catchDyn doQry printSqlError
    where
      doQry = do
        conn <- connectPostgreSQL testConnStr
        res <- HDBC.quickQuery conn "SELECT * FROM testtable" []
        putStrLn $ show res ++ "\n"
        let sqlEpochTimes = map (\n -> res!!0!!n) [6,7,8]
        mapM_ (\et -> putStrLn $ show ((HDBC.fromSql et)::ClockTime)) sqlEpochTimes
        
      printSqlError :: HDBC.SqlError -> IO ()
      printSqlError = print


